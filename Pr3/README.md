# Практична робота 3

## Завдання 3.1

### Опис
Запустіть Docker-контейнер і поекспериментуйте з максимальним лімітом ресурсів відкритих файлів. Для цього виконайте команди у вказаному порядку:
```
$ ulimit -n
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3000
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3001
$ ulimit -n 2000
$ ulimit -n
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3000
```
Як наступне вправу, повторіть перераховані команди з root-правами.

### Процес виконання
1. Запустіть Docker-контейнер з образом Ubuntu:
   ```sh
   docker run -it ubuntu bash
   ```
2. Виконайте послідовно всі команди, зазначені у завданні, як звичайний користувач. Зверніть увагу на повідомлення про помилки при спробі встановити ліміт вище максимально дозволеного.
3. Повторіть ті ж команди з root-правами (наприклад, через `sudo su`).
4. Порівняйте значення лімітів для звичайного користувача та root.

### Результати
- На початку побачите поточний ліміт відкритих файлів (наприклад, 1024).
- Після зміни ліміту на 3000 — якщо дозволено, значення зміниться, якщо ні — отримаєте помилку.
- При спробі встановити ліміт вище максимально дозволеного (`ulimit -n 3001`) — отримаєте повідомлення про помилку.
- Для root-прав ліміти можуть бути вищими.
- Після кожної зміни перевіряйте поточні значення командою `ulimit -n` та через `ulimit -aS | grep "open files"`.

### Скріншот виконання
![Скріншот виконання](task1/screenshot.png)

---

## Завдання 3.2

### Опис
У Docker-контейнері встановіть утиліту perf(1). Поекспериментуйте з досягненням процесом встановленого ліміту.

### Процес виконання
1. Запустіть контейнер Ubuntu:
   ```sh
   docker run -it ubuntu bash
   ```
2. Встановіть утиліту perf:
   ```sh
   apt update && apt install -y perf
   ```
3. Запустіть команду для збору статистики:
   ```sh
   perf stat -e cycles,instructions ls
   ```
4. Встановіть ліміт на кількість відкритих файлів або інший ресурс (наприклад, через `ulimit -n 10`) і спробуйте запустити perf для процесу, який відкриває багато файлів.
5. Спостерігайте за поведінкою perf при досягненні ліміту (можливі помилки, попередження, неповна статистика).

### Результати
- Після запуску perf отримаєте статистику виконання команди (кількість циклів, інструкцій тощо).
- Якщо ліміт ресурсу досягнуто, perf може завершитись з помилкою або попередженням.
- При зменшенні ліміту до дуже низького значення — можливі помилки відкриття файлів.

### Скріншот виконання
![Скріншот виконання](task2/screenshot.png)

---

## Завдання 3.3

### Опис
Напишіть програму, що імітує кидання шестигранного кубика. Імітуйте кидки, результати записуйте у файл, для якого попередньо встановлено обмеження на його максимальний розмір (max file size). Коректно обробіть ситуацію перевищення ліміту.

### Код
[task3/dice.c](task3/dice.c)

### Процес виконання
1. Скомпілюйте програму:
   ```sh
   gcc dice.c -o dice
   ```
2. Запустіть програму:
   ```sh
   ./dice
   ```
3. Програма встановлює обмеження на розмір файлу (наприклад, 100 байт) і починає записувати результати кидків у файл `dice_results.txt`.
4. Коли розмір файлу досягає ліміту, програма виводить повідомлення "Досягнуто ліміту розміру файлу!" і завершує роботу.
5. Перевірте вміст файлу `dice_results.txt` — у ньому буде лише частина результатів, що вмістилися у встановлений ліміт.

### Результати
- У консолі з'явиться повідомлення про досягнення ліміту.
- У файлі `dice_results.txt` буде записано кілька кидків (стільки, скільки дозволяє ліміт).
- Програма завершується коректно при перевищенні ліміту.

### Скріншот виконання
![Скріншот виконання](task3/screenshot.png)

---

## Завдання 3.4

### Опис
Напишіть програму, що імітує лотерею, вибираючи 7 різних цілих чисел у діапазоні від 1 до 49 і ще 6 з 36. Встановіть обмеження на час ЦП (max CPU time) і генеруйте результати вибору чисел (7 із 49, 6 із 36). Обробіть ситуацію, коли ліміт ресурсу вичерпано.

### Код
[task4/lottery.c](task4/lottery.c)

### Процес виконання
1. Скомпілюйте програму:
   ```sh
   gcc lottery.c -o lottery
   ```
2. Запустіть програму:
   ```sh
   ./lottery
   ```
3. Програма встановлює обмеження на час ЦП (наприклад, 1 секунда) і генерує унікальні числа для двох лотерей.
4. Якщо програма перевищує ліміт часу ЦП, вона виводить повідомлення "Ліміт часу ЦП вичерпано!" і завершує роботу.
5. Якщо ліміт не перевищено, на екрані з'являються результати вибору чисел.

### Результати
- Якщо генерація чисел відбулася швидко — на екрані буде два рядки з числами (7 із 49, 6 із 36).
- Якщо ліміт часу ЦП вичерпано — програма повідомить про це і завершиться.

### Скріншот виконання
![Скріншот виконання](task4/screenshot.png)

---

## Завдання 3.5

### Опис
Напишіть програму для копіювання одного іменованого файлу в інший. Імена файлів передаються у вигляді аргументів. Програма має:
- перевіряти, чи передано два аргументи, інакше виводити "Program need two arguments";
- перевіряти доступність першого файлу для читання, інакше виводити "Cannot open file .... for reading";
- перевіряти доступність другого файлу для запису, інакше виводити "Cannot open file .... for writing";
- обробляти ситуацію перевищення обмеження на розмір файлу.

### Код
[task5/copyfile.c](task5/copyfile.c)

### Процес виконання
1. Скомпілюйте програму:
   ```sh
   gcc copyfile.c -o copyfile
   ```
2. Підготуйте тестовий файл для копіювання (наприклад, створіть файл `source.txt` з довільним вмістом).
3. Запустіть програму з аргументами:
   ```sh
   ./copyfile source.txt dest.txt
   ```
4. Якщо не передано два аргументи — програма виведе відповідне повідомлення і завершиться.
5. Якщо перший файл недоступний для читання — буде повідомлення про помилку.
6. Якщо другий файл недоступний для запису — буде повідомлення про помилку.
7. Якщо під час копіювання досягнуто ліміту розміру файлу — програма виведе повідомлення "Досягнуто ліміту розміру файлу!" і завершить копіювання.
8. Перевірте вміст файлу-призначення — він міститиме лише частину даних, якщо ліміт був досягнутий.

### Результати
- Програма коректно обробляє всі помилки та ліміти.
- У разі досягнення ліміту розміру файлу — частина даних копіюється, і виводиться відповідне повідомлення.
- Якщо все гаразд — файл копіюється повністю.

### Скріншот виконання
![Скріншот виконання](task5/screenshot.png)

---

## Завдання 3.6

### Опис
Напишіть програму, що демонструє використання обмеження (max stack segment size). Підказка: рекурсивна програма активно використовує стек.

### Код
[task6/stacklimit.c](task6/stacklimit.c)

### Процес виконання
1. Скомпілюйте програму:
   ```sh
   gcc stacklimit.c -o stacklimit
   ```
2. Запустіть програму:
   ```sh
   ./stacklimit
   ```
3. Програма встановлює обмеження на розмір стеку (наприклад, 8 КБ) і починає рекурсивно викликати функцію, збільшуючи глибину.
4. Коли стек вичерпується, програма аварійно завершується (можливий segmentation fault або інше повідомлення).
5. У консолі можна побачити, до якої глибини дійшла рекурсія.

### Результати
- Програма виводить глибину рекурсії до моменту вичерпання стеку.
- Після досягнення ліміту — аварійне завершення програми.

### Скріншот виконання
![Скріншот виконання](task6/screenshot.png)

---

## Завдання 3.14

### Опис
Запустити контейнер з різними значеннями ulimit та порівняти поведінку програм.

### Процес виконання
1. Запустіть контейнер з різними параметрами ulimit, наприклад:
   ```sh
   docker run --ulimit nofile=1000:1000 -it ubuntu bash
   docker run --ulimit nofile=5000:5000 -it ubuntu bash
   ```
2. У кожному контейнері скомпілюйте та запустіть попередні програми (наприклад, dice, copyfile, lottery, stacklimit).
3. Порівняйте, як змінюється поведінка програм при різних лімітах (наприклад, чи вдається відкрити більше файлів, чи виникають помилки при досягненні ліміту).
4. Зробіть висновки щодо впливу різних значень ulimit на роботу програм.

### Результати
- При низьких значеннях ulimit програми можуть завершуватись з помилками або не виконувати всі операції.
- При високих значеннях — програми працюють коректніше, якщо не досягають інших лімітів.
- Можна побачити різницю у поведінці при копіюванні файлів, генерації чисел, роботі з perf тощо.

### Скріншот виконання
![Скріншот виконання](task14/screenshot.png) 